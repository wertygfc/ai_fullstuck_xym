# 1. 说说你对vue的理解
- 是什么
    是一个js框架，是一个用于创建单页应用的web应用框架，主旨是为了简化web的开发，主要是靠MVVM的驱动方式来实现视图的更新

- 特性
1. MVVM (Model - View - ViewModel)(用数据驱动页面更新)
    1. Model --- 模型层(模版，就是用来处理业务逻辑的代码)
    2. View --- 视图层(html页面)
    3. ViewModel --- 视图模型层(用于将模型和视图进行连接通信)(通过数据绑定来实现视图层和模型层的双向绑定)
        - 响应式

    vue与传统的html/js相比，性能方面没有区别，但是开发效率大大提升

2. 组件化
    1. 代码复用
    2. 降低整体的耦合度，便于维护

3. 指令 (如：v-if/v-for....)
    1. 大大减少了手动操作dom的代码 


# 2. 说说你对SPA（单页应用）的理解
- 是什么
    只有一个html页面，本质上只需要控制某一个代码片段被拿到该html中生效而已

- 特点
    1. 优点：
        页面在任何时候都不会重新加载，不会打断用户体验
    2. 缺点：
        存在首屏加载时间过长
        不利于SEO（搜索引擎）的抓取：单页应用一定是用js来渲染的，他只爬html，所以爬不到关键字


        - 解决首屏加载时间过长的手段：
        1. 路由懒加载
        2. 服务端渲染ssr：（还能解决SEO抓取关键字问题）
            在vue项目中再启动一个node服务时，负责直接响应首页的代码片段，项目其他的代码片段依然保持原有的加载方式，这样就能让用户第一时间看到首页


# 3. 说说你对双向绑定的理解
- 是什么
    模版层的数据变更会导致视图层的更新，视图层的数据更新也会导致模版层的数据改变

- 原理 (ViewModel的原理)
    1. 监听器：对所有的数据进行监听
    2. 解析器：对每个元素的节点的指令进行解析，根据这个指令进行替换数据以及更新相应数据

- 双向绑定的理解
    1. vue的数据源会被劫持，在劫持的过程中为属性做依赖收集。vue中的观察者watcher负责更新视图，依赖收集到的是观察者watcher的实例对象，当属性值发生变更时会触发依赖，进而触发视图更新函数
    2. 在数据劫持的同时，vue会编译模版，解析指令，当视图层的数据发生变更时，编译器中绑定的函数会被触发，进而获取到最新的数据值，再次通知watcher去触发依赖


# 说说vue2和vue3的区别
    - 选项式api 和 组合式api
        - this 不需要了，更好地支持了函数式编程
        - 选项式api，代码量大的话，data+methods+getters 相关的逻辑被分开了
        - 组合式api，可以使用函数式编程，让reactive/ref + methods + onMounted 以业务为单位放一起

    - 响应式原理
        - vue2 defineProperty （一次性代理完） 数组（索引变化）
        - vue3，使用了Proxy，有13种拦截方法，性能更好（懒代理）
        - vue2的响应式原理是依赖收集，vue3的响应式原理是发布订阅
        因为核心就是  拦截 + track(get) + trigger(set) + effect

        - weakMap 理解
            依赖关系收集是考全局的唯一的weakMap，以响应式对象为key，再试他的一些属性，proxy可以一次性代理，值就是用track手机的函数数组（effects），全部执行
            - 为什么用weakMap
            组件有很多，响应式对象有很多，路由组件有很多，当组件下线，路由切换，有些响应式对象就不用维护了，，weakMap会在响应式对象被垃圾回收后自动删除，可以解决内存泄漏的问题


# 4. 生命周期


# 5. 组件通信
1. 父子通信  子组件props接受
2. 子父通信  子组件通过emit发布一个事件，父组件订阅该事件
3. 子父通信  子组件拿到父组件的数据并修改后emit出来，父组件靠v-model实现双向绑定
4. 子父通信  子组件defineExpose暴露出来值，父组件利用ref读取整个子组件对象来获取值
5. 父子通信  父组件provide，子（后辈）组件inject
6. 兄弟通信  EventBus 靠mitt插件实现
7. 兄弟通信  vuex || pinia

    插槽：1. 匿名插槽（默认插槽） 2.具名插槽 3.作用域插槽

    
# 6. v-if v-for 的优先级
    - 选项式api，v-if v-for 的优先级是 v-for > v-if ，但会报警告，因为性能浪费
    - 组合式api，v-if v-for 的优先级是 v-if > v-for ，如果if用到for中的变量，那会报错
    - vue3修正了vue2的bug，v-if=“false”时，没必要渲染


# 7. data为什么要是一个函数，不是个对象
    因为data如果是对象，那么组件之间的数据源会相互影响


# 8. 父子组件谁的生命周期先执行
父组件挂载前，子组件挂载前，子组件挂载后，父组件挂载后


# 9. 什么是虚拟DOM
1. 一个用js对象来描述的DOM结构
2. 当一次操作导致多处DOM更新，不使用虚拟DOM，浏览器需要重新一个一个构建DOM树，导致多次渲染。
    但是少量DOM更新，diff算法同样会存在性能开销。
3. 跨平台


# 10. 说说diff
- 同层比较
- 深度优先
pathVnode步骤：
1. 判断节点是不是文本，是的话直接更新文本
2. 比较节点类型，属性是否相同，不同则直接替换
3. 比较子节点，不断生成补丁包

- 双端队列
    提升比较的效率

# 11. vue中的修饰符
在 Vue.js 中，修饰符是用于改变指令行为的特殊标记，可以在指令后面以 `.` 的方式添加。Vue 提供了一些常用的修饰符，用于扩展或修改指令的功能，常见的修饰符包括：

1. `.prevent`：
   - 阻止默认事件的触发，相当于调用 `event.preventDefault()`。

2. `.stop`：
   - 阻止事件冒泡，相当于调用 `event.stopPropagation()`。

3. `.capture`：
   - 使用事件捕获模式，即从外层元素向内部元素传播事件。

4. `.self`：
   - 只当事件是从事件源（即当前元素）触发时才触发回调。

5. `.once`：
   - 事件只会触发一次，之后将自动移除监听器。

6. `.passive`：
   - 声明事件的默认行为不会被阻止，可以提高移动端滚动性能。

7. `.native`：
   - 监听组件根元素的原生事件，而不是组件内部使用 `v-on` 绑定的事件。

8. `.sync`：
   - 双向绑定的语法糖，用于子组件向父组件传递数据。

这些修饰符可以在 Vue 的指令（如 `v-on`、`v-bind` 等）中使用，以修改指令的行为或实现特定功能。在实际开发中，根据需要选择合适的修饰符来达到预期的效果。



# 12. vue2 和 vue3 的区别
1. 速度更快：
    - 虚拟DOM实现的函数被重写，效率提升。
    - 编译模板的优化
2. 体积减小：
    - tree-shaking更彻底:剔除类似于打印命令这种无用代码
3. 更易维护
    - 函数式编程
    - 更好的TS支持

4. 更接近原生语法
    - 

5. v3 template 模板中支持多个节点

6. teleport 组件

7. 响应式区别


# Vue.js 中常见的性能优化策略
1. 虚拟 DOM 和响应式数据：
   - Vue 使用虚拟 DOM 来减少直接操作 DOM 的次数，通过比对虚拟 DOM 的变化来更新真实 DOM，从而提高性能。
   - 合理使用响应式数据，避免过多的计算属性和监听器，以减少不必要的更新。

2. 组件优化：
   - 合理划分组件，避免一个组件包含过多的子组件，尽量保持组件的粒度合适。
   - 使用 `v-if` 和 `v-show` 来控制组件的显示与隐藏，避免不必要的渲染。
   - 合理使用 `key` 属性来帮助 Vue 识别节点，减少不必要的重新渲染。

3. 列表性能优化：
   - 使用 `v-for` 渲染列表时，最好为每项指定唯一的 `key`，以提高 Vue 的渲染效率。
   - 避免在列表中使用复杂的表达式或方法，可以提前处理数据以减少计算量。

4. 懒加载和分片：
   - 对于大型应用，可以考虑懒加载路由组件，只在需要的时候才加载相关组件。
   - 可以使用 Webpack 的代码分片（code splitting）功能，将应用拆分为多个小模块，按需加载，减小初始加载体积。

5. 服务端渲染（SSR）：
   - 对于 SEO 效果要求较高的应用，可以考虑使用 Vue 的服务端渲染（SSR），提升首屏加载速度和 SEO 表现。

6. 事件处理优化：
   - 避免在频繁触发的事件处理中进行耗时操作，可以通过节流（throttling）和防抖（debouncing）来优化事件处理。

7. 性能监控：
   - 使用浏览器的开发者工具（如 Chrome DevTools）或性能分析工具来监控页面性能，找出性能瓶颈并进行优化。

以上是一些常见的 Vue.js 性能优化策略，根据实际情况可以结合具体场景进行调整和优化。